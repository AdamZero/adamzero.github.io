<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="正式开始学习之前,先看看主要内容:  分别根据单词频度,单词位置 ,单词距离 ,来搜索相关网页并排序 pagerank网站计分 神经网络模拟用户行为 前馈算法 反向传播学习法">
<meta name="keywords" content="编程,读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="集体智慧编程-搜索与排名">
<meta property="og:url" content="http://yoursite.com/集体智慧编程-搜索与排名/index.html">
<meta property="og:site_name" content="还珠楼">
<meta property="og:description" content="正式开始学习之前,先看看主要内容:  分别根据单词频度,单词位置 ,单词距离 ,来搜索相关网页并排序 pagerank网站计分 神经网络模拟用户行为 前馈算法 反向传播学习法">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https:///">
<meta property="og:image" content="https://pan.baidu.com/s/1qYr74BU">
<meta property="og:image" content="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=4a65cdbb4b34970a537e187df4a3baad/29381f30e924b8994bb77cac64061d950b7bf69f.jpg">
<meta property="og:image" content="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=33afcd8303f79052fb124f6c6d9abcaf/d009b3de9c82d158dfb4e7218a0a19d8bc3e426f.jpg">
<meta property="og:updated_time" content="2018-10-12T09:24:58.496Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="集体智慧编程-搜索与排名">
<meta name="twitter:description" content="正式开始学习之前,先看看主要内容:  分别根据单词频度,单词位置 ,单词距离 ,来搜索相关网页并排序 pagerank网站计分 神经网络模拟用户行为 前馈算法 反向传播学习法">
<meta name="twitter:image" content="https:///">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"hide","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/集体智慧编程-搜索与排名/"/>





  <title>集体智慧编程-搜索与排名 | 还珠楼</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">还珠楼</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">还珠重地,闲人勿闯</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-杂谈">
          <a href="/awesome" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            杂谈
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/集体智慧编程-搜索与排名/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冷鸢">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="还珠楼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">集体智慧编程-搜索与排名</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-12T17:03:04+08:00">
                2018-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  27
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p class="description"></p>

<p><img src="https://" alt="" style="width:100%"></p>
<p>正式开始学习之前,先看看主要内容:</p>
<ul>
<li>分别根据<strong>单词频度</strong>,<strong>单词位置</strong> ,<strong>单词距离</strong> ,来搜索相关网页并排序</li>
<li><strong>pagerank</strong>网站计分</li>
<li><strong>神经网络</strong>模拟用户行为</li>
<li><strong>前馈</strong>算法</li>
<li><strong>反向传播</strong>学习法</li>
</ul>
<a id="more"></a>
<h2 id="源数据"><a href="#源数据" class="headerlink" title="源数据"></a>源数据</h2><p>由于书中数据源已经无法下载到了,所以自己从wiki中爬了一些网页的数据,此处整理出来方便使用</p>
<p><strong>如果对爬虫内容不感兴趣的话可以在文末下载到相应代码,也可以得到数据源</strong></p>
<p>在本文的数据分析中,我们要根据用户搜索的关键字来查找相关度最高的网页,即类似搜索引擎的功能,所以我们需要的数据有:<strong>网站网址,网站内容(以单词记录,记录位置),网站指向的链接</strong></p>
<p>为了存储数据,需要建5张表:</p>
<ul>
<li>wordlocation单词位置表: id,wordid(单词的id),urlid(单词所在url对应id),position(单词在文中位置)</li>
<li>wordlist单词表:id ,word,urlid(懒得连查所以这里也存了一份..)</li>
<li>urllist网页表:id,url,rank(网页分数)</li>
<li>linkwords关键字指向表:id,wordid,linkid单词指向的链接的id</li>
<li>link网页指向表:id,fromid网站的id,toid网站指向的网站的id</li>
</ul>
<p>有了这5张表之后,我们就可以愉快的开始爬虫之旅啦</p>
<p>在正式开始爬取网页数据之前,我们先把要爬的网页地址全部准备好:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 爬取网址</span><br><span class="line">def getUrls(url_start=&apos;https://en.wikipedia.org/wiki/Tiger&apos;):</span><br><span class="line">    url_base = &apos;https://en.wikipedia.org&apos;</span><br><span class="line">    urls, allurls, newurls = set(), set(), set()</span><br><span class="line">    urls.add(url_start)</span><br><span class="line">    allurls.add(url_start)</span><br><span class="line">    for i in range(1):</span><br><span class="line">        for url_resource in urls:</span><br><span class="line">            try:</span><br><span class="line">                res = requests.get(url_resource, timeout=2)</span><br><span class="line">                # 只看正文下的内容</span><br><span class="line">                links = BeautifulSoup(str(BeautifulSoup(res.content, &apos;lxml&apos;)(&apos;div&apos;, id=&apos;bodyContent&apos;)), &apos;lxml&apos;)(&apos;a&apos;)</span><br><span class="line">                for link in links:</span><br><span class="line">                    if &apos;href&apos; in dict(link.attrs):</span><br><span class="line">                        link_to = link[&apos;href&apos;]</span><br><span class="line">                        # 外链和本文连接直接忽略</span><br><span class="line">                        if link_to.startswith(&apos;http&apos;) or link_to.startswith(&apos;#&apos;): continue</span><br><span class="line">                        url = parse.urljoin(url_base, link_to)</span><br><span class="line">                        if url.find(&quot;&apos;&quot;) != -1: continue</span><br><span class="line">                        url = url.split(&apos;#&apos;)[0]</span><br><span class="line">                        newurls.add(url)</span><br><span class="line">            except:</span><br><span class="line">                pass</span><br><span class="line">        urls = newurls.copy()</span><br><span class="line">        allurls.update(newurls)</span><br><span class="line">    with open(&apos;urls.txt&apos;, &apos;w&apos;) as f:</span><br><span class="line">        for item in allurls:</span><br><span class="line">            try:</span><br><span class="line">                f.write(item + &apos;\n&apos;)</span><br><span class="line">            except:</span><br><span class="line">                pass</span><br></pre></td></tr></table></figure>
<p>运行上述代码可以生成一个包含了千余个网址的文件,我们就要从这些文件里取得我们要爬的分析数据,由于本文的主要记录搜索和排序的功能,具体的分析过程就不赘述了,直接贴代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">def readUrls():</span><br><span class="line">    with open(&apos;urls.txt&apos;, &apos;r&apos;) as f:</span><br><span class="line">        urls = f.read().split(&apos;\n&apos;)</span><br><span class="line">        return urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getUrlId(conn, cursor, url):</span><br><span class="line">    # 查询当前url地址在表中的位置</span><br><span class="line">    cursor.execute(&apos;select id from urllist where url=%s&apos;, (url,))</span><br><span class="line">    urlid = cursor.fetchone()</span><br><span class="line">    # 如果没有,新增并重新获取urlid</span><br><span class="line">    if urlid is None:</span><br><span class="line">        cursor.execute(&apos;insert into urllist(`url`) values(%s)&apos;, (url,))</span><br><span class="line">        conn.commit()</span><br><span class="line">        cursor.execute(&apos;select id from urllist where url=%s&apos;, (url,))</span><br><span class="line">        urlid = cursor.fetchone()</span><br><span class="line">    return urlid[0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 根据url地址爬取相关数据,并写入数据库</span><br><span class="line">def parseData(urls):</span><br><span class="line">    conn = connector.connect(user=&apos;root&apos;, password=&apos;wangweijie0&apos;, database=&apos;wwj&apos;)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    worldid = 1</span><br><span class="line">    ignores = [&apos;a&apos;, &apos;and&apos;, &apos;it&apos;, &apos;or&apos;, &apos;of&apos;, &apos;to&apos;, &apos;is&apos;, &apos;in&apos;, &apos;and&apos;, &apos;but&apos;, &apos;the&apos;, &apos;ma&apos;]</span><br><span class="line">    # 循环urlid</span><br><span class="line">    for url in urls:</span><br><span class="line">        try:</span><br><span class="line">            res = requests.get(url, timeout=2)</span><br><span class="line"></span><br><span class="line">            urlid = getUrlId(conn, cursor, url)</span><br><span class="line">            soup = BeautifulSoup(str(BeautifulSoup(res.content, &apos;lxml&apos;)(&apos;div&apos;, id=&apos;bodyContent&apos;)), &apos;lxml&apos;)</span><br><span class="line">            splitter = re.compile(&apos;\\W+&apos;)</span><br><span class="line">            words = [t.lower() for t in splitter.split(soup.get_text()) if</span><br><span class="line">                     t != &apos;&apos; and t not in ignores]</span><br><span class="line">            # 单词入库</span><br><span class="line">            for position in range(len(words)):</span><br><span class="line">                # 写库</span><br><span class="line">                cursor.execute(&apos;insert into wordlist(`word`,`urlid`)values(%s,%s)&apos;, (words[position], urlid))</span><br><span class="line">                cursor.execute(&apos;insert into wordlocation(`urlid`,`wordid`,`position`)values(%s,%s,%s)&apos;, (</span><br><span class="line">                    urlid, worldid, position + 1))</span><br><span class="line">                worldid += 1</span><br><span class="line">            conn.commit()</span><br><span class="line"></span><br><span class="line">            # 只看正文下的内容</span><br><span class="line">            links = soup(&apos;a&apos;)</span><br><span class="line">            for link in links:</span><br><span class="line">                if &apos;href&apos; in dict(link.attrs):</span><br><span class="line">                    link_to = link[&apos;href&apos;]</span><br><span class="line">                    # 外链和本文连接直接忽略</span><br><span class="line">                    if link_to.startswith(&apos;http&apos;) or link_to.startswith(&apos;#&apos;): continue</span><br><span class="line">                    link_url = parse.urljoin(&apos;https://en.wikipedia.org&apos;, link_to)</span><br><span class="line">                    if link_url.find(&quot;&apos;&quot;) != -1: continue</span><br><span class="line">                    link_url = link_url.split(&apos;#&apos;)[0]</span><br><span class="line">                    linkid = getUrlId(conn, cursor, link_url)</span><br><span class="line"></span><br><span class="line">                    cursor.execute(&apos;insert into link(`fromid`,`toid`)values(%s,%s)&apos;, (urlid, linkid))</span><br><span class="line">                    # 查询当前href的字在word中而id不再linkwords中的第一个</span><br><span class="line">                    cursor.execute(</span><br><span class="line">                        &apos;select ws.id from wordlist ws where ws.urlid=%s and ws.word=%s &apos;,</span><br><span class="line">                        (urlid, link.text))</span><br><span class="line">                    wordids = cursor.fetchall()</span><br><span class="line">                    if wordids is not None and len(wordids) &gt; 0:</span><br><span class="line">                        for wordid in wordids:</span><br><span class="line">                            cursor.execute(&apos;select lw.wordid from linkwords lw where lw.wordid=%s &apos;, (wordid[0],))</span><br><span class="line">                            r = cursor.fetchone()</span><br><span class="line">                            if r is None or len(r) == 0:</span><br><span class="line">                                cursor.execute(&apos;insert into linkwords(`wordid`,`linkid`)values(%s,%s)&apos;,</span><br><span class="line">                                               (wordid[0], linkid))</span><br><span class="line">                                conn.commit()</span><br><span class="line">                                break</span><br><span class="line"></span><br><span class="line">            conn.commit()</span><br><span class="line">        except BaseException as e:</span><br><span class="line">            conn.rollback()</span><br><span class="line"></span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:由于wiki里侧边栏连接太多,所以我只爬取了正文的内容,侧边栏和下边栏,包括文章的标题都没有爬取</p>
<p>准备好数据之后就可以愉快的开始我们的搜索引擎之路了:</p>
<h2 id="搜索与排名"><a href="#搜索与排名" class="headerlink" title="搜索与排名"></a>搜索与排名</h2><p>​     根据关键字查表搜索可以得到和关键字相关的网页,但是乱序的网页中很难找到我们真正想要的,所以我们需要对网页进行一个排名,这样更容易找到用户想看到的东西,我们进行排名主要依靠<strong>单词频度</strong>,<strong>单词位置</strong>,<strong>单词距离</strong> ,<strong>网页评分</strong> </p>
<p>​    下面就对这几个评估方法展开叙述:</p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>​    首先,我们得构造一个方法,可以根据用户输入的关键字查找到相关的网页:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class search():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.conn = connector.connect(user=&apos;root&apos;, password=&apos;wangweijie0&apos;, database=&apos;wwj&apos;)</span><br><span class="line">        self.cursor = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        if self.conn:</span><br><span class="line">            self.conn.close</span><br><span class="line"></span><br><span class="line">    # 查询的入口,kw是关键字字符串,以空格分割</span><br><span class="line">    def searchK(self, kw):</span><br><span class="line">        kw.lower()</span><br><span class="line">        words = kw.split(&apos; &apos;)</span><br><span class="line">        self.result = &#123;&#125;</span><br><span class="line">        for word in words:</span><br><span class="line">            self.cursor.execute(&apos;select w.urlid,u.url from wordlist w,urllist u where w.word=%s and u.id=w.urlid&apos;,</span><br><span class="line">                                (word,))</span><br><span class="line">            # 查到所有连接的urlid</span><br><span class="line">            urlids = self.cursor.fetchall()</span><br><span class="line">            self.result[word] = urlids</span><br><span class="line">        self.data = self.handledata()</span><br><span class="line">        if len(self.data) == 0:</span><br><span class="line">            print(&apos;无查询结果&apos;)</span><br><span class="line">        else:</span><br><span class="line">            self.getscoredlist()</span><br></pre></td></tr></table></figure>
<p>​    在这里,我为了方便,直接取到了和关键字相关的网页和网页在数据库中的id,由于查到的网页有很多重复的,所以构造了一个handledata方法对查询结果进行了优化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 处理数据,返回共有的url和这些url出现的次数</span><br><span class="line">  def handledata(self):</span><br><span class="line">      # 记录原始数据,但是把数据元素从[(1,),(2,)]变成了[1,2]</span><br><span class="line">      data2 = self.result.copy()</span><br><span class="line">      # 记录新数据,新数据之中去除了重复的url</span><br><span class="line">      newdata = &#123;&#125;</span><br><span class="line">      for word, urls in data2.items():</span><br><span class="line">          urlids = [u[0] for u in urls]</span><br><span class="line">          # 把所有元素添加进来</span><br><span class="line">          urlset = []</span><br><span class="line">          for urlid in urlids:</span><br><span class="line">              if urlid not in urlset:</span><br><span class="line">                  urlset.append(urlid)</span><br><span class="line">          newdata[word] = urlset</span><br><span class="line">      # 通过reduce函数,把新数据中的value变成set并求交集,之后在变回list,这样得到了两个的交集</span><br><span class="line">      urllist = list(reduce(lambda x, y: set(x) &amp; set(y), [newdata[item] for item in newdata]))</span><br><span class="line">      # 计算交集url出现的次数</span><br><span class="line">      return dict([(k, sum([data2[word].count(k) for word in data2])) for k in urllist])</span><br></pre></td></tr></table></figure>
<p>​    调用函数,输入关键字就可以查到与之相关的网页了,虽然目前我们并没有做任何优化和排序,但是还是可以看出这些网页与关键字之间是有连续的</p>
<p>​    有必要先提前解释一下result和data的意思:result代表了初始的查询结果,数据很不好看,但是是原始数据,data是对result进行了优化,得到了关键字共同出现的url和这些关键字共同出现的次数之和</p>
<h3 id="归一函数"><a href="#归一函数" class="headerlink" title="归一函数"></a>归一函数</h3><p>​    由于我们再排序的时候用到了多种方法,有的方法是分数高的网页靠前,有的方法是分数低的网页靠前,所以我们需要一个归一化函数来把这些网页的评分进行优化,让他们的值域和变化方向一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 把数据都转化到0-1之间</span><br><span class="line">    def nomalizescores(self, scores, smallbetter=True):</span><br><span class="line">        vsamll = 0.00001</span><br><span class="line">        # 小了好,小的分数高,小的当分子即可</span><br><span class="line">        if smallbetter:</span><br><span class="line">            minscore = min(scores.values())</span><br><span class="line">            res = [(float(minscore) / max(vsamll, v), k) for k, v in scores.items()]</span><br><span class="line">        # 大了好,大的分数高,大的当分母即可</span><br><span class="line">        else:</span><br><span class="line">            maxscore = max(scores.values())</span><br><span class="line">            # 避免分母是0</span><br><span class="line">            if maxscore == 0: maxscore = vsamll</span><br><span class="line">            res = [(float(v) / maxscore, k) for k, v in scores.items()]</span><br><span class="line"></span><br><span class="line">        return dict(res)</span><br></pre></td></tr></table></figure>
<p>​    这样我们就得到了一个值在0-1之间的评价,并且评价越高说明排名应该越靠前</p>
<h3 id="单词频度"><a href="#单词频度" class="headerlink" title="单词频度"></a>单词频度</h3><p>​    <strong>单词频度</strong> 就是用户搜索的单词在网页正文中出现的次数,我们有理由认为关键词出现次数多的网页更符合用户的预期,其排名应该更靠前</p>
<p>​    由于之前已经统计过网站出现的次数,所以此处很简单:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#  根据出现次数打分,多个单词的话以出现次数之和算</span><br><span class="line">def countscore(self):</span><br><span class="line">    return self.nomalizescores(self.data, smallbetter=False)</span><br></pre></td></tr></table></figure>
<h3 id="单词位置"><a href="#单词位置" class="headerlink" title="单词位置"></a>单词位置</h3><p>​    另一个判断网页相关度的简单方法是单词位置,如果单词出现的位置更靠前,比如出现在标题栏或者简介栏,那么这个网页应该跟我们搜索的关键词关联更紧密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 根据单词之间的距离/单词位置计算</span><br><span class="line">  # 其实可以把单词位置记录在单词表,可以一起查出来结果,比这样效率高得多</span><br><span class="line">  # type记录计算距离还是计算位置</span><br><span class="line">  def disscore(self, type=&apos;distance&apos;):</span><br><span class="line">      # 按单词之间距离来</span><br><span class="line">      if type == &apos;distance&apos;:</span><br><span class="line">          fn = lambda m, n: m - n</span><br><span class="line">      # 按单词的位置来</span><br><span class="line">      else:</span><br><span class="line">          fn = lambda m, n: m + n</span><br><span class="line"></span><br><span class="line">      if len(self.result) == 1:</span><br><span class="line">          return 1</span><br><span class="line">      positions = dict([(item, &#123;&#125;) for item in self.data])</span><br><span class="line">      totalscores = &#123;&#125;</span><br><span class="line">      for urlid in self.data:</span><br><span class="line">          for word in self.result:</span><br><span class="line">              self.cursor.execute(</span><br><span class="line">                  &apos;select wl.position from wordlocation wl,wordlist w where w.word=%s and w.urlid=%s and wl.wordid=w.id&apos;,</span><br><span class="line">                  (word, urlid))</span><br><span class="line">              p = self.cursor.fetchall()</span><br><span class="line">              positions[urlid][word] = [item[0] for item in p]</span><br><span class="line">      # item是url,ps中包含了url中的关键字和出现的位置</span><br><span class="line">      for item, ps in positions.items():</span><br><span class="line">          totalscores.setdefault(item, 9999)</span><br><span class="line">          # 每次取两个关键字比较</span><br><span class="line">          for k1 in ps:</span><br><span class="line">              for k2 in ps:</span><br><span class="line">                  # 不比较一样的关键字</span><br><span class="line">                  if k1 == k2: continue</span><br><span class="line">                  # 取两个关键字的所有值比较,取到差最小或者和最小的一对,记录</span><br><span class="line">                  # 由于关键字可能不止两个,所以两两计算的结果加在一起作为最终的结果</span><br><span class="line">                  totalscores[item] += min([min([abs(fn(m, n)) for m in ps[k1]]) for n in ps[k2]])</span><br><span class="line">      return self.nomalizescores(totalscores, smallbetter=True)</span><br></pre></td></tr></table></figure>
<p>​    在上面的代码中,我们查到关键字的位置并构造了关于url和word的结果集,遍历结果集并把这些单词的位置求和,得到两两之间最小的位置和,这就是两个位置最靠前的单词的位置,重复这一过程,可以把多个关键字两两组合求得所有的关键字的位置总和</p>
<p>​    举个栗子方便理解:</p>
<p>​    查询关键字’a b c’,得到了一些url,我们取一个url,可以得到这个url里这些单词出现的位置</p>
<p>url:{a:[10,5,7,1],b:[13,7,2],c[18,4,9]}</p>
<p>​    那么我们可以先计算ab的最小位置和<strong>1+2=3</strong>,再计算ac的最小位置和<strong>1+4=5</strong>,bc的最小位置和<strong>2+4=6</strong> ,所以最终计算结果应该是<strong>3+5+6=14</strong></p>
<p>​    上述存在<strong>重复计算</strong>,但是由于归一化函数的存在,重复计算<strong>不会影响</strong>我们的最终判定结果,所以没有做处理</p>
<p>​    可能我描述的不太清楚,最主要还是理清思路,实在无法理解我说的是啥的可以debug跟一下代码,就明了</p>
<h2 id="单词距离"><a href="#单词距离" class="headerlink" title="单词距离"></a>单词距离</h2><p>​    我们查询多个单词的时候,更倾向于被查询的单词在文中出现的位置相近,如果两个单词出现在同一文章中但是距离过远,那可能就不是我们想要的结果</p>
<p>​    由于单词距离和单词位置都是根据每个关键字的位置来的,所以和单词位置合并到一起了,区别只是单词距离取得是位置差(也就是<strong>距离</strong>)的最小值,单词位置取得是位置和(也就是<strong>位置</strong>)的最小值</p>
<h2 id="PageRank计分法"><a href="#PageRank计分法" class="headerlink" title="PageRank计分法"></a>PageRank计分法</h2><p>​    PageRank根据网页的权重以及网页指向其他链接的个数计算而成</p>
<p>​    这个值表示了用户在浏览时到达这个网页的可能性,值越大说明用户越倾向于进入这个网页,那这个网页权重显然应该更高</p>
<p>​    计算公式:</p>
<blockquote>
<p>p=0.15+0.85*(p1/l1+p2/l2+…)</p>
</blockquote>
<p>​    p和l分别代表了指向这个网页的权重和外链数</p>
<p>举个栗子:</p>
<p><img src="https://pan.baidu.com/s/1qYr74BU" alt="PageRank"></p>
<p>​    在上图中,B网页有0.5的权重,指向4个网页,C网页有0.3的权重,指向四个网页,D网页有0.2的权重,只指向A</p>
<p>​    所以我们计算A的权重:</p>
<p>​    Ra=0.15+0.85*(0.5/4+0.3/4+0.2/1)=0.49</p>
<p>​    计算pagerank的方法其实很简单,只需要知道原网页权重和指向的个数就可以了,但是如果一组网页都没有权重,我们应该怎么办呢?</p>
<p>​    解决的办法是为每个网页都设置一个初始值,本文设置的是1,然后对多有网页进行pagerank的计算,替代初始值.多次执行计算之后就可以得到非常接近真实值的pagerank</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 计算网页分值</span><br><span class="line">   def pagerank(self):</span><br><span class="line">       self.cursor.execute(&apos;select id from urllist&apos;)</span><br><span class="line">       urlidlist = [item[0] for item in self.cursor.fetchall()]</span><br><span class="line">       self.cursor.execute(&apos;select toid,fromid from link&apos;)</span><br><span class="line">       linklist = self.cursor.fetchall()</span><br><span class="line">       # todata里放着所有指向这个链接的urlid</span><br><span class="line">       todata = &#123;&#125;</span><br><span class="line">       # fromdata放着所有此链接指向的链接的数量</span><br><span class="line">       fromdata = &#123;&#125;</span><br><span class="line">       for item in linklist:</span><br><span class="line">           todata.setdefault(item[0], [])</span><br><span class="line">           todata[item[0]].append(item[1])</span><br><span class="line">           fromdata.setdefault(item[1], 0)</span><br><span class="line">           fromdata[item[1]] += 1</span><br><span class="line">       # 初始化所有rank为1</span><br><span class="line">       ranks = dict([(urlid, 1) for urlid in urlidlist])</span><br><span class="line">       # 循环30次计算pagerank,基本可以保证接近现实</span><br><span class="line">       for i in range(30):</span><br><span class="line">           for urlid, fl in todata.items():</span><br><span class="line">               ranks[urlid] = 0.15 + 0.85 * sum([float(ranks[fromid]) / fromdata[fromid] for fromid in fl])</span><br><span class="line">       for urlid in ranks:</span><br><span class="line">           self.cursor.execute(&apos;update urllist set rank=%s where id=%s&apos;, (ranks[urlid], urlid))</span><br><span class="line"></span><br><span class="line">       self.conn.commit()</span><br></pre></td></tr></table></figure>
<h2 id="神经网络-模拟用户行为"><a href="#神经网络-模拟用户行为" class="headerlink" title="神经网络,模拟用户行为"></a>神经网络,模拟用户行为</h2><p>​    在线应用最大的优势就是可以得到用户操作的实时反馈</p>
<p>​    对于搜索引擎而言,可以获得用户在搜索时点击网页时的选择情况,让我们可以更好地展示用户喜欢的网页</p>
<p>​    在许多神经网络中,都以一组神经元相连,我们即将学习的这种称为<strong>多层感知机</strong> ,他们都有一层<strong>输出层</strong>和一层<strong>输出层</strong>,以及中间的<strong>隐藏层</strong>.输入层和输出层用于交互,隐藏层用于筛选和计算</p>
<p>​    下面我们就开始进行模拟用户行为的神经网络训练</p>
<p>​    为了保存神经元之间的数据,首先我们得建数据库:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class searchnet():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.conn = connector.connect(user=&apos;root&apos;, password=&apos;wangweijie0&apos;, database=&apos;wwj&apos;)</span><br><span class="line">        self.cursor = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        if self.conn:</span><br><span class="line">            self.conn.close</span><br><span class="line"></span><br><span class="line">    # 建表</span><br><span class="line">    def createtable(self):</span><br><span class="line">        self.cursor.execute(</span><br><span class="line">             &apos;create table inputhidden(`id` integer not null auto_increment,`fromid` varchar(80) not null,`toid` varchar(80) not null,`strength` float not null,primary key (`id`))auto_increment=1&apos;)</span><br><span class="line">        self.cursor.execute(</span><br><span class="line">             &apos;create table hiddenoutput(`id` integer not null  auto_increment,`fromid` varchar(80) not null,`toid` varchar(80) not null,`strength` float not null,primary key (`id`))auto_increment=1&apos;)</span><br><span class="line">        self.cursor.execute(</span><br><span class="line">            &apos;create table hiddennode(`id`integer not null auto_increment, `createkey` varchar(80) not null,primary key (`id`))auto_increment=1&apos;)</span><br><span class="line"></span><br><span class="line">        self.conn.commit()</span><br></pre></td></tr></table></figure>
<p>​    这三张表分别记录了输入层到隐藏层的所有节点对应的id以及连接的强度(也可以称为权重),并记录了查询关键字</p>
<p>​    有了数据库之后我们需要两个方法用于设置和获取当前连接的强度:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 获取链接强度,即链接权重</span><br><span class="line">def getstrength(self, fromid, toid, layer):</span><br><span class="line">    # 输入-隐藏,sd(strength-default)是默认strength</span><br><span class="line">    if layer == 0:</span><br><span class="line">        tablename, sd = &apos;inputhidden&apos;, -0.2</span><br><span class="line">        self.cursor.execute(&apos;select strength from inputhidden where fromid = %s and toid = %s&apos;, (fromid, toid))</span><br><span class="line">        res = self.cursor.fetchone()</span><br><span class="line">        if res is None:</span><br><span class="line">            return sd</span><br><span class="line">        return res[0]</span><br><span class="line">    # 隐藏-输出</span><br><span class="line">    elif layer == 1:</span><br><span class="line">        tablename, sd = &apos;hiddenoutput&apos;, 0</span><br><span class="line">        self.cursor.execute(&apos;select strength from hiddenoutput where fromid = %s and toid = %s&apos;, (fromid, toid))</span><br><span class="line">        res = self.cursor.fetchone()</span><br><span class="line">        if res is None:</span><br><span class="line">            return sd</span><br><span class="line">        return res[0]</span><br><span class="line"></span><br><span class="line"># 设置链接强度</span><br><span class="line">def setstrength(self, fromid, toid, strength, layer):</span><br><span class="line">    # 输入-隐藏</span><br><span class="line">    if layer == 0:</span><br><span class="line">        tablename = &apos;inputhidden&apos;</span><br><span class="line">        self.cursor.execute(&apos;select strength from inputhidden where fromid=%s and toid=%s&apos;,</span><br><span class="line">                            (fromid, toid))</span><br><span class="line">        res = self.cursor.fetchone()</span><br><span class="line">        # 无数据,插入数据</span><br><span class="line">        if res is None:</span><br><span class="line">            self.cursor.execute(&apos;insert into inputhidden(`fromid`,`toid`,`strength`) values(%s,%s,%s)&apos;,</span><br><span class="line">                                (fromid, toid, strength))</span><br><span class="line">        # 有数据,更新</span><br><span class="line">        else:</span><br><span class="line">            self.cursor.execute(&apos;update inputhidden set strength=%s where fromid=%s and toid=%s&apos;,</span><br><span class="line">                                (strength, fromid, toid))</span><br><span class="line">    # 隐藏-输出</span><br><span class="line">    elif layer == 1:</span><br><span class="line">        tablename = &apos;hiddenoutput&apos;</span><br><span class="line">        self.cursor.execute(&apos;select strength from hiddenoutput where fromid=%s and toid=%s&apos;,</span><br><span class="line">                            (fromid, toid))</span><br><span class="line">        res = self.cursor.fetchone()</span><br><span class="line">        # 无数据,插入数据</span><br><span class="line">        if res is None:</span><br><span class="line">            self.cursor.execute(&apos;insert into hiddenoutput(`fromid`,`toid`,`strength`) values(%s,%s,%s)&apos;,</span><br><span class="line">                                (fromid, toid, strength))</span><br><span class="line">        # 有数据,更新</span><br><span class="line">        else:</span><br><span class="line">            self.cursor.execute(&apos;update hiddenoutput set strength=%s where fromid=%s and toid=%s&apos;,</span><br><span class="line">                                (strength, fromid, toid))</span><br><span class="line">    self.conn.commit()</span><br></pre></td></tr></table></figure>
<p>​    <strong>这里我尝试把tablename赋值给一个变量,然后把变量扔到sql语句中,但是一直报错,所以不得不采用这种重复代码的方法,如果您知道怎么动态设置tablename,望告知,万分感谢</strong></p>
<p>​    在构建神经网络时,我们基本上都会先建立一个巨大的网络,把所有节点都构造出来.但是本例子中由于数据量不大,所以临时建立节点效率更高</p>
<p>​    每次用户传入一组数据,我们查看这组数据的节点是否已经建立,如果没有建立的话就添加节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 建立链接网</span><br><span class="line">    def generatehiddennode(self, words, urls):</span><br><span class="line">        if len(words) &gt; 3: return None</span><br><span class="line">        # 通过排序保证key的唯一性</span><br><span class="line">        createkey = &apos; &apos;.join(sorted([str(word) for word in words]))</span><br><span class="line">        self.cursor.execute(&apos;select id from hiddennode where createkey=%s &apos;, (createkey,))</span><br><span class="line">        res = self.cursor.fetchone()</span><br><span class="line">        # 当前节点尚未建立,建立节点,设置权重(连接强度)</span><br><span class="line">        if res is None:</span><br><span class="line">            # 新建隐层节点</span><br><span class="line">            self.cursor.execute(&apos;insert into hiddennode(`createkey`) values(%s)&apos;, (createkey,))</span><br><span class="line">            for word in words:</span><br><span class="line">                self.setstrength(word, createkey, 1 / len(words), 0)</span><br><span class="line"></span><br><span class="line">            for url in urls:</span><br><span class="line">                self.setstrength(createkey, url, 0.1, 1)</span><br><span class="line"></span><br><span class="line">            self.conn.commit()</span><br></pre></td></tr></table></figure>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>如果每次我们都把输入值当做输出值这种线性做法来模拟网络,很多时候并不能满足我们的要求,所以需要引入非线性因素来让我们的网络功能更加丰富,也更加接近神经元(根据生物学的神经结构,刺激)</p>
<p>通常我们用得到的激活函数:</p>
<ul>
<li><p>tanh双曲正切函数</p>
<p>​    <img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=4a65cdbb4b34970a537e187df4a3baad/29381f30e924b8994bb77cac64061d950b7bf69f.jpg" alt="tanh"></p>
<p>​</p>
</li>
<li><p>Sigmoid</p>
</li>
</ul>
<p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=33afcd8303f79052fb124f6c6d9abcaf/d009b3de9c82d158dfb4e7218a0a19d8bc3e426f.jpg" alt="sigmoid"></p>
<ul>
<li>ReLU</li>
</ul>
<h3 id="前馈法"><a href="#前馈法" class="headerlink" title="前馈法"></a>前馈法</h3><p>​    通过输入正向计算输出的算法称为前馈算法,这个算法是开环的</p>
<p>​    在计算神经网络的输出值之前,我们需要把要分析的链接网矩阵构建起来</p>
<p>​    首先根据关键字找到相关的隐藏节点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 获取所有和输入层,输出层相关的隐藏节点</span><br><span class="line">    def getallhiddenids(self, words, urls):</span><br><span class="line">        ll = &#123;&#125;</span><br><span class="line">        createkey = &apos; &apos;.join(sorted([str(word) for word in words]))</span><br><span class="line">        for word in words:</span><br><span class="line">            self.cursor.execute(&apos;select toid from inputhidden where fromid=%s&apos;, (word,))</span><br><span class="line">            for row in self.cursor.fetchall(): ll[row[0]] = 1</span><br><span class="line"></span><br><span class="line">        for url in urls:</span><br><span class="line">            cur = self.cursor.execute(&apos;select fromid from hiddenoutput where toid=%s&apos;, (url,))</span><br><span class="line">            for row in self.cursor.fetchall(): ll[row[0]] = 1</span><br><span class="line"></span><br><span class="line">        return list(ll.keys())</span><br></pre></td></tr></table></figure>
<p>​    构建链接矩阵:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 建立链接矩阵</span><br><span class="line">   def setupnetword(self, words, urls):</span><br><span class="line">       self.words = words</span><br><span class="line">       self.urls = urls</span><br><span class="line">       self.hiddens = self.getallhiddenids(words, urls)</span><br><span class="line"></span><br><span class="line">       # 初始化输出数据,默认输入层输出都是1,wio,who,woo分别代表输入层,隐藏层,输出层的输出</span><br><span class="line">       self.wio = [1.0] * len(self.words)</span><br><span class="line">       self.who = [0.0] * len(self.hiddens)</span><br><span class="line">       self.woo = [0.0] * len(self.urls)</span><br><span class="line"></span><br><span class="line">       # 初始化权重矩阵,ih,ho分别代表输入层到隐藏层和隐藏层到输出层</span><br><span class="line">       # 在矩阵中,隐藏层代表列名,输入输出都是行名</span><br><span class="line">       self.ih = [[self.getstrength(fromid, toid, 0) for toid in self.hiddens] for fromid in self.words]</span><br><span class="line">       self.ho = [[self.getstrength(fromid, toid, 1) for fromid in self.hiddens] for toid in self.urls]</span><br></pre></td></tr></table></figure>
<p>​    通过这个矩阵,我们把所有节点的相关信息(输入,输出,强度)全部拿到,就可以计算结果了</p>
<p>​    为了便于计算,我们假设输入层的输出全部为1,也就是隐藏层的输入是1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 前馈算法,计算输出值</span><br><span class="line">def feedfoward(self):</span><br><span class="line">    for i in range(len(self.words)):</span><br><span class="line">        # 输入层的输出结果默认为1</span><br><span class="line">        self.wio[i] = 1</span><br><span class="line">    # 对每一个隐藏层,计算到这个输隐藏层的输入,再通过tanh函数计算出输出</span><br><span class="line">    # j代表这是第几列,列名是隐藏层节点的名字</span><br><span class="line">    for j in range(len(self.hiddens)):</span><br><span class="line">        sum = 0</span><br><span class="line">        # i代表第几行,行名输入层/输出层名字</span><br><span class="line">        # 这里对某个隐藏节点的所有输入与连接强度的乘积求和,得到隐藏节点的输入</span><br><span class="line">        for i in range(len(self.words)):</span><br><span class="line">            sum += self.wio[i] * self.ih[i][j]</span><br><span class="line">        # 利用激活函数求得输出</span><br><span class="line">        self.who[j] = tanh(sum)</span><br><span class="line">    # 同上,计算输出层的输出</span><br><span class="line">    for i in range(len(self.urls)):</span><br><span class="line">        sum = 0</span><br><span class="line">        for j in range(len(self.hiddens)):</span><br><span class="line">            sum += self.who[j] * self.ho[i][j]</span><br><span class="line">        # 利用激活函数求得输出</span><br><span class="line">        self.woo[i] = tanh(sum)</span><br><span class="line">    return self.woo[:]</span><br></pre></td></tr></table></figure>
<p>这里一定要理解,在输入-隐藏-输出这个模型中一共有3次激活(即内耗)两次传递.所以正常来说应该用到<strong>三次激活函数</strong>,<strong>两次损失函数</strong>,但是由于我们制定了输入层的输出是1,所以少用了一次激活函数</p>
<p>根据前馈算法中计算出的输出值,我们就知道误差有多少了,然后逆向传播,训练我们的神经网络,修改连接权重即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 反向传播,训练机器,改变链接权重</span><br><span class="line">  def backpropagate(self, targets, N=0.5):</span><br><span class="line">      # 计算输出层的误差,这个误差也就是输出层的输入误差</span><br><span class="line">      ho_deviation = [0.0] * len(self.urls)</span><br><span class="line">      for i in range(len(targets)):</span><br><span class="line">          # 体现在最终输出的误差</span><br><span class="line">          error = targets[i] - self.woo[i]</span><br><span class="line">          # 反函数求输出层的输入值并计算误差</span><br><span class="line">          ho_deviation[i] = self.dtanh(self.woo[i]) * error</span><br><span class="line">      # 根据输出层误差计算隐藏层误差,这个误差是隐藏层的输入误差</span><br><span class="line">      ih_deviation = [0.0] * len(self.hiddens)</span><br><span class="line">      for j in range(len(self.hiddens)):</span><br><span class="line">          for i in range(len(self.urls)):</span><br><span class="line">              error = 0</span><br><span class="line">              # 把误差按当前各个神经元的传递损耗分配下去,计算一个隐藏层的全部误差</span><br><span class="line">              # 通过这个损耗,已经把输出层的输入转化成了隐藏层的输出</span><br><span class="line">              error += ho_deviation[i] * self.ho[i][j]</span><br><span class="line">          # 对当前隐藏层的输出求反,得到了隐藏层输入,进而求得隐藏层输入误差</span><br><span class="line">          ih_deviation[j] = self.dtanh(self.who[j]) * error</span><br><span class="line"></span><br><span class="line">      # 修改隐藏层到输出层之间的连接强度</span><br><span class="line">      for j in range(len(self.hiddens)):</span><br><span class="line">          for i in range(len(self.urls)):</span><br><span class="line">              # 应该修改的值是隐藏层的输出值*误差</span><br><span class="line">              change = self.who[j] * ho_deviation[i]</span><br><span class="line">              # N代表学习效率/成功率</span><br><span class="line">              self.ho[i][j] += N * change</span><br><span class="line">      # 修改输入层到隐藏层之间的链接强度</span><br><span class="line">      for j in range(len(self.hiddens)):</span><br><span class="line">          for i in range(len(self.words)):</span><br><span class="line">              # 根据隐藏节点的误差求得输入层到隐藏层的误差</span><br><span class="line">              change = self.wio[i] * ih_deviation[j]</span><br><span class="line">              self.ih[i][j] += N * change</span><br></pre></td></tr></table></figure>
<p>​    这里我再解释一下,反向传播的时候,过了一次连接(隐藏层-输出层),两次激活(隐藏层和输出层),理解这点至关重要.</p>
<p>​    <strong>但是此处我还有一个地方比较疑惑,计算权重误差的时候居然是以上层输出*实际误差,而不是实际误差/上层输出,如果有大佬能解惑的话请告诉我0.0</strong></p>
<p>​    计算完成之后我们需要把数据保存到数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def updateData(self):</span><br><span class="line">       for j in range(len(self.hiddens)):</span><br><span class="line">           for i in range(len(self.urls)):</span><br><span class="line">               self.cursor.execute(&apos;update hiddenoutput set strength=%s where fromid=%s and toid=%s&apos;,</span><br><span class="line">                                   (self.ho[i][j], self.hiddens[j], self.urls[i]))</span><br><span class="line"></span><br><span class="line">       for j in range(len(self.hiddens)):</span><br><span class="line">           for i in range(len(self.words)):</span><br><span class="line">               self.cursor.execute(&apos;update inputhidden set strength=%s where fromid=%s and toid=%s&apos;,</span><br><span class="line">                                   (self.ih[i][j], self.words[i], self.hiddens[j]))</span><br><span class="line"></span><br><span class="line">       self.conn.commit()</span><br></pre></td></tr></table></figure>
<p>​    训练的完整函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def train(self, words, urls, target):</span><br><span class="line">        # 生成节点</span><br><span class="line">        # 建立连接矩阵</span><br><span class="line">        # 获取链接强度</span><br><span class="line">        # 在反向训练之前调用前馈算法,这样可以计算好所有输出值</span><br><span class="line">        # 根据target生成输出层输出结果,反向传播修改矩阵数据</span><br><span class="line">        # 修改数据(输入层-隐藏层和隐藏层-输出层都要修改)</span><br><span class="line">        self.generatehiddennode(words, urls)</span><br><span class="line">        self.setupnetword(words, urls)</span><br><span class="line">        self.feedfoward()</span><br><span class="line">        targets = [0.0] * len(urls)</span><br><span class="line">        targets[urls.index(target)] = 1</span><br><span class="line">        self.backpropagate(targets)</span><br><span class="line">        self.updateData()</span><br></pre></td></tr></table></figure>
<p>这样我们的训练函数就完成了,可以自己尝试一下哦,用法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">se = searchnet()</span><br><span class="line">for i in range(10):</span><br><span class="line">    se.train([&apos;机器&apos;, &apos;学习&apos;], [&apos;机器&apos;, &apos;学习&apos;, &apos;机器学习&apos;], &apos;机器学习&apos;)</span><br><span class="line">    print(se.getreslut([&apos;机器&apos;, &apos;学习&apos;], [&apos;机器&apos;, &apos;学习&apos;, &apos;机器学习&apos;]))</span><br><span class="line"></span><br><span class="line">print(se.getreslut([&apos;机器&apos;], [&apos;机器&apos;, &apos;学习&apos;, &apos;机器学习&apos;]))</span><br></pre></td></tr></table></figure>
<p>最后,我们只需要把求结果的函数导入到排名中并分配权重就可以了,这里不做赘述</p>
<p><a href="https://github.com/AdamZero/MeachineLearning/tree/master/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B/chapter4" target="_blank" rel="noopener">完整源码</a></p>
<p><strong>有任何问题请私信或留言</strong> </p>

      
    </div>

    <div>
      
        
<div class="my-copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/集体智慧编程-搜索与排名/">集体智慧编程-搜索与排名</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 冷鸢 的个人博客">冷鸢</a></p>
  <p><span>发布时间:</span>2018年10月12日 - 17:03</p>
  <p><span>最后更新:</span>2018年10月12日 - 17:24</p>
  <p><span>原始链接:</span><a href="/集体智慧编程-搜索与排名/" title="集体智慧编程-搜索与排名">http://yoursite.com/集体智慧编程-搜索与排名/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://yoursite.com/集体智慧编程-搜索与排名/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>
</div>
<script>
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({
          title: "",
          text: '复制成功',
          icon: "success",
          showConfirmButton: true
          });
	});
    });
</script>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/集体智慧编程-聚类/" rel="next" title="集体智慧编程-聚类">
                <i class="fa fa-chevron-left"></i> 集体智慧编程-聚类
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/集体智慧编程-优化/" rel="prev" title="集体智慧编程-优化">
                集体智慧编程-优化 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MDI3MS8xNjc5OA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="冷鸢" />
            
              <p class="site-author-name" itemprop="name">冷鸢</p>
              <p class="site-description motion-element" itemprop="description">冷鸢</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Alvabill" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.freecodecamp.cn/alvabill" target="_blank" title="fcc">
                      
                        <i class="fa fa-fw fa-globe"></i>fcc</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/439a6eee60e1" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-globe"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://blog.csdn.net/weixin_38796712" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#源数据"><span class="nav-number">1.</span> <span class="nav-text">源数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜索与排名"><span class="nav-number">2.</span> <span class="nav-text">搜索与排名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#搜索"><span class="nav-number">2.1.</span> <span class="nav-text">搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归一函数"><span class="nav-number">2.2.</span> <span class="nav-text">归一函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单词频度"><span class="nav-number">2.3.</span> <span class="nav-text">单词频度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单词位置"><span class="nav-number">2.4.</span> <span class="nav-text">单词位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单词距离"><span class="nav-number">3.</span> <span class="nav-text">单词距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PageRank计分法"><span class="nav-number">4.</span> <span class="nav-text">PageRank计分法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#神经网络-模拟用户行为"><span class="nav-number">5.</span> <span class="nav-text">神经网络,模拟用户行为</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#激活函数"><span class="nav-number">5.1.</span> <span class="nav-text">激活函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前馈法"><span class="nav-number">5.2.</span> <span class="nav-text">前馈法</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冷鸢</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">12.9k</span>
  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

</body>
</html>
